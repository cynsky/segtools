#' segmentation class description
#'
#' @param x a \code{segmentation} object generated by
#'   \code{\link{segmentation}}
#' @param nseg number of segment chosen
#' @param ncluster number of classes chosen
#' @param ... additional arguments
#' @name segmentation-class
NULL

#' \code{print.segmentation} prints object of \code{segmentation} class
#' @param max.level argument to be passed to utils::str()
#' @rdname segmentation-class
#' @export


print.segmentation <- function(x,max.level = 1, ...){
  utils::str(x,max.level = max.level)
}


#' \code{plot.segmentation} plot object of \code{segmentation} class
#' - wrapper for \code{\link{plot_segm}}
#' @param interactive whether plot are interactive (dygraphs/leaflet) or not (ggplot2)
#' @param xcol column for x axis. can be POSIXct
#' @param html whether htmltools::tagList should be applied on the returned object
#'   object for integrating in html pages
#' @rdname segmentation-class
#' @inheritParams plot_segm
#' @export

plot.segmentation <- function(x, nseg=NULL, ncluster=NULL, interactive=F, xcol="indice", order, ...) {

  if (missing(order)){
    if (x$type == "home-range") order <- F
    if (x$type == "behavior") order <- T
  }
  if( x$seg.type == "segclust"){
    if (is.null(ncluster)){
      ncluster <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("BIC-selected number of class : ",ncluster," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("User-specified number of class :",ncluster,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    g <- plot_segm(data = x$data, output = x$outputs[[paste(ncluster,"class -",nseg, "segments")]], interactive=interactive, diag.var = x$`Diagnostic variables`,x_col = xcol,  order = order, ...)


  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }

    g <- plot_segm(data = x$data,
                   output = x$outputs[[paste(nseg, "segments")]],
                   interactive=interactive,
                   diag.var = x$`Diagnostic variables`,
                   x_col = xcol,
                   order = order, ...)
  } else if (x$seg.type == "HMM" | x$seg.type == "shiftfit" | x$seg.type == "depmixS4" ){
    g <- plot_segm(data = x$data, output = x$outputs, diag.var = x$`Diagnostic variables`,x_col = xcol, order = order, ...)

  }
  return(g)
}




#' \code{likelihood.segmentation} deprecated function for plotting likelihood estimates of \code{segmentation} object. Now use \link{plot_likelihood}.
#' @rdname segmentation-class
#' @export

likelihood.segmentation <- function(x, ...) {
  .Deprecated("plot_likelihood")
  plot_likelihood(x)
}

#' \code{plot_likelihood} plot likelihood estimates of a \code{segmentation} object
#' - works only for picard segmentation.
#' @rdname segmentation-class
#' @export

plot_likelihood <- function(x) {

  if( x$seg.type == "segclust"){
    likedat <- x$likelihood
    # nseg.bic <- x$Kopt.lavielle
    # tmpdf =  filter(li("nseg"=nseg.bic, "likelihood" = x$likelihood$likelihood[which(x$likelihood$nseg == nseg.bic)])
    g <- ggplot2::ggplot(likedat[(likedat$ncluster != 0) & is.finite(likedat$likelihood), ],ggplot2::aes_string(x="nseg",y="likelihood",col="factor(ncluster)"))+
      ggplot2::geom_point()+
      ggplot2::geom_line()+
      ggplot2::xlab("Number of segments")+
      ggplot2::ylab("log-Likelihood")+
      # ggplot2::geom_point(data = tmpdf,ggplot2::aes(x=nseg,y=likelihood,col = fact),size = 3)+
      ggplot2::scale_color_discrete(name="Number of \nCluster")

  } else if( x$seg.type == "segmentation"){
    nseg.lav <- x$Kopt.lavielle
    tmpdf =  data.frame("nseg"=nseg.lav, "likelihood" = x$likelihood$likelihood[which(x$likelihood$nseg == nseg.lav)])
    nudgeY = (max(x$likelihood$likelihood,na.rm=T)-min(x$likelihood$likelihood,na.rm=T))/20
    nudgeX = (max(x$likelihood$nseg,na.rm=T)-min(x$likelihood$nseg,na.rm=T))/6
    g <- ggplot2::ggplot(x$likelihood,ggplot2::aes_string(x="nseg",y="likelihood"))+
      ggplot2::geom_point()+
      ggplot2::geom_line()+
      ggplot2::xlab("Number of segments")+
      ggplot2::ylab("log-Likelihood")+
      ggplot2::scale_color_discrete(name="Number of \nCluster") +
      ggplot2::geom_point(data = tmpdf, ggplot2::aes_string(x="nseg", y="likelihood"), size = 3)+
      ggplot2::geom_text(data = tmpdf,  ggplot2::aes_string(x="nseg", y="likelihood"), label="Lavielle-selected optimum", nudge_x = nudgeX, nudge_y = -nudgeY  ,size = 3)+
      ggplot2::scale_x_continuous(breaks = scales::pretty_breaks())

  }
  return(g)
}

#' \code{get_likelihood} returns likelihood estimates of a \code{segmentation} object. Deprecated, now use \link{logLik.segmentation}.
#' @rdname segmentation-class
#' @export

get_likelihood <- function(x) {
  .Deprecated("logLik.segmentation")
  return(x$likelihood)
}


#' \code{logLik.segmentation} returns log-likelihood estimates of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

logLik.segmentation <- function(object, ...) {
  return(object$likelihood)
}




#' \code{plot_BIC} plot BIC estimates of a \code{segmentation} object
#' - works only for segclust algorithm.
#' @rdname segmentation-class
#' @export

plot_BIC <- function(x) {

  if( x$seg.type == "segclust"){
    likedat <- x$BIC
    ncluster.BIC = x$ncluster.BIC
    Kopt.BIC =  x$Kopt.BIC[ncluster.BIC]
    ClusterOpt <- data.frame("ncluster" = ncluster.BIC, "nseg" =Kopt.BIC,"BIC" = likedat[(likedat$ncluster == ncluster.BIC) & (likedat$nseg == Kopt.BIC), ]$BIC)

    nudgeY = (max(likedat$BIC[is.finite(likedat$BIC)],na.rm=T)-min(likedat$BIC[is.finite(likedat$BIC)],na.rm=T))/20
    nudgeX = (max(likedat$nseg,na.rm=T)-min(likedat$nseg,na.rm=T))/6

    ncluster.BIC = 2:max(likedat$ncluster)
    Kopt.BIC =  x$Kopt.BIC[-1]
    SegOpt <- data.frame(ncluster= ncluster.BIC, nseg = Kopt.BIC)
    SegOpt <- dplyr::left_join(SegOpt,likedat, by = c("ncluster", "nseg"))
    g <- ggplot2::ggplot(likedat[is.finite(likedat$BIC), ], ggplot2::aes_string(x="nseg",y="BIC",col="factor(ncluster)"))+
      ggplot2::geom_point()+
      ggplot2::geom_line()+
      ggplot2::xlab("Number of segments")+
      ggplot2::ylab("BIC penalized log-Likelihood")+
      ggplot2::geom_point(data=SegOpt,shape = 15,size=2)+
      ggplot2::geom_point(data=ClusterOpt,shape = 19, size = 3.5)+
      ggplot2::geom_text(data=ClusterOpt, size = 3,label="selected optimum", nudge_x = - nudgeX, nudge_y = nudgeY)+
      ggplot2::scale_color_discrete(name="Number of \nClusters")+
      ggplot2::scale_x_continuous(breaks = scales::pretty_breaks())

  } else if( x$seg.type == "segmentation"){
    stop("no BIC estimates for segmentation only algorithm")
  }
  return(g)
}


#' \code{BIC} returns BIC estimates of a \code{segmentation} object when
#' segmentation/clustering has been run.
#' @param object a segmentation-class object, created by segclust.
#' @rdname segmentation-class
#' @importFrom stats BIC
#' @export

BIC.segmentation <- function(object, ...) {
  return(object$BIC)
}

#' \code{stateplot} plot state distribution of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

stateplot <- function(x,nseg = NULL,ncluster = NULL,order = NULL){
  if (is.null(order)){
    if (x$type == "home-range") order <- F
    if (x$type == "behavior") order <- T
  }
  if( x$seg.type == "segclust"){
    if (is.null(ncluster)){
      ncluster <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("BIC-selected number of class : ",ncluster," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("User-specified number of class :",ncluster,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    g <- plot_states(x$outputs[[paste(ncluster,"class -",nseg, "segments")]],x$`Diagnostic variables`,order= order)

  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    g <- plot_states(x$outputs[[paste(nseg, "segments")]],x$`Diagnostic variables`,order= order)

  } else if( x$seg.type == "HMM" | x$seg.type == "shiftfit" | x$seg.type == "depmixS4" ){
    g <- plot_states(x$outputs,x$`Diagnostic variables`,order= order)

  }
  return(g)
}

#' \code{states} return data.frame with states statistics a \code{segmentation} object
#' @rdname segmentation-class
#' @export

states <- function(x,nseg = NULL,ncluster = NULL){
  if( x$seg.type == "segclust"){
    if (is.null(order)){
      if (x$type == "home-range") order <- F
      if (x$type == "behavior") order <- T
    }
    if (is.null(ncluster)){
      ncluster <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("BIC-selected number of class : ",ncluster," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("User-specified number of class :",ncluster,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    return(x$outputs[[paste(ncluster,"class -",nseg, "segments")]]$states)

  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    return(x$outputs[[paste(nseg, "segments")]]$states)
  } else if( x$seg.type == "HMM" | x$seg.type == "shiftfit" | x$seg.type == "depmixS4" ){
    return(x$outputs$states)
  }
}

#' \code{segment} return data.frame with segment information of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

segment <- function(x,nseg = NULL,ncluster = NULL){
  if( x$seg.type == "segclust"){
    if (is.null(ncluster)){
      ncluster <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("BIC-selected number of class : ",ncluster," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("User-specified number of class :",ncluster,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(ncluster,"class -",nseg, "segments")]]$states
    segmentdf <- x$outputs[[paste(ncluster,"class -",nseg, "segments")]]$segments
    totdf <- dplyr::left_join(segmentdf,statesdf, by = "state")
    return(totdf)
  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(nseg, "segments")]]$states
    segmentdf <- x$outputs[[paste(nseg, "segments")]]$segments
    totdf <- dplyr::left_join(segmentdf,statesdf, by = "state")
    return(totdf)
  } else if( x$seg.type == "HMM" | x$seg.type == "shiftfit" | x$seg.type == "depmixS4" ){
    statesdf <- x$outputs$states
    segmentdf <- x$outputs$segments
    totdf <- dplyr::left_join(segmentdf,statesdf, by = "state")
    return(totdf)
  }
}

#' \code{augment.segmentation} return data.frame with original data and state information of a \code{segmentation} object
#' @param colname_state column name for the added state column
#' @rdname segmentation-class
#' @export

augment.segmentation<- function(x,nseg = NULL,ncluster=NULL,colname_state = "state", ...){
  if(any(colnames(x$data) == colname_state)) stop(paste(colname_state,"already exists as column names of the data.frame. Cannot erase"))

  if( x$seg.type == "segclust"){
    if (is.null(ncluster)){
      ncluster <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("BIC-selected number of class : ",ncluster," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("User-specified number of class :",ncluster,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(ncluster,"class -",nseg, "segments")]]$states

    df.segm  <- segment(x,nseg=nseg,ncluster=ncluster)
  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(nseg, "segments")]]$states
    df.segm  <- segment(x,nseg=nseg)
  } else if( x$seg.type == "HMM" | x$seg.type == "shiftfit" | x$seg.type == "depmixS4"){
    statesdf <- states(x)
    df.segm  <- segment(x)
  }
  x$data$indice <- 1:nrow(x$data)
  data <- x$data
  data[,colname_state] <- df.segm[findInterval(data$indice,df.segm$begin,rightmost.closed = F,left.open = F),"state"]
  totdf <- dplyr::left_join(data,statesdf, by = "state")

  return(totdf)

}



#' \code{segmap} create maps with object of \code{segmentation} class
#'   (interpreting latitude/longitude)
#' @rdname segmentation-class
#' @inheritParams map_segm
#' @export

segmap <-  function(x, interactive=F, nseg = NULL, ncluster = NULL, html=F,
                    scale=100, width=400, height=400, order = NULL, pointsize = 1, linesize = 0.5 , ...){

  if (is.null(order)){
    if (x$type == "home-range") order <- F
    if (x$type == "behavior") order <- T
  }
  if( x$seg.type == "segclust"){
    if (is.null(ncluster)){
      ncluster <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("BIC-selected number of class : ",ncluster," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("User-specified number of class :",ncluster,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    outputs = x$outputs[[paste(ncluster,"class -",nseg, "segments")]]
  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    outputs = x$outputs[[paste(nseg, "segments")]]
  }  else if( x$seg.type == "HMM" | x$seg.type == "shiftfit" | x$seg.type == "depmixS4" ){
    outputs = x$outputs
  }
  map <- map_segm(data=x$data,output=outputs,interactive = interactive, html = html, scale=scale,width=width,height=height,order=order,pointsize = pointsize, linesize = linesize, ...)

  return(map)
}

#' \code{stationarity} extract mean and sd for each tier of segment of a
#' \code{segmentation} class object
#' @param max.level argument to be passed to utils::str()
#' @rdname segmentation-class
#' @export


stationarity <- function(x,nseg = NULL, ncluster = NULL, ...){
  if( x$seg.type == "segclust"){
    if (is.null(ncluster)){
      ncluster <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("BIC-selected number of class : ",ncluster," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[ncluster]
      message(paste("User-specified number of class :",ncluster,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    output = x$outputs[[paste(ncluster,"class -",nseg, "segments")]]
  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    output <- x$outputs[[paste(nseg, "segments")]]
  } else if (x$seg.type == "HMM" | x$seg.type == "shiftfit" | x$seg.type == "depmixS4" ){
    stop("stationarity() works only for segmentation() and segclust()")
  }
  data <- x$data
  data$indice <- 1:nrow(data)
  df.states <- output[[2]]
  df.segm <- output[[1]]


  df_stat <- NULL
  for(seg in 1:nrow(df.segm)){
    if(df.segm[seg,'end']-df.segm[seg,'begin'] < 3){
      df_stat <- rbind(df_stat,df.segm[seg,])
    } else {
      tmp <- rbind(df.segm[seg,],df.segm[seg,],df.segm[seg,])
      begin <- df.segm[seg,'begin']
      end <- df.segm[seg,'end']
      tmp$end[1] <- begin + round((end-begin) / 3) - 1
      tmp$begin[2] <- begin + round((end-begin) / 3)
      tmp$end[2] <- begin + round((end-begin) * 2 / 3) -1
      tmp$begin[3] <- begin + round((end-begin) * 2 / 3)
      tmp$state <- paste("seg",seg,"-tier",c(1,2,3),sep="")
      df_stat <- rbind(df_stat,tmp)
    }
  }
  diag.var <- x$`Diagnostic variables`
  # df_stat$state <- 1:nrow(df_stat)
  df_stat_states <- calc_stat_states(data,df_stat,diag.var= diag.var, order.var = diag.var[1])
  # prepMu_stat <- find_mu_sd(df_stat_states,diag.var)
  df_stat_states$prop <- NULL
  df_stat_states$state_ordered <- NULL
  df_stat <- dplyr::select(df_stat,state,begin,end)
  dfreturn <- left_join(df_stat_states,df_stat, by = "state")
  return(dfreturn)
}
