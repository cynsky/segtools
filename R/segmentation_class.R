#' segmentation class description
#'
#' @param x a \code{segmentation} object generated by
#'   \code{\link{segmentation}}
#' @param nseg number of segment chosen
#' @param nclass number of classes chosen
#' @name segmentation-class
NULL

#' \code{print.segmentation} prints object of \code{segmentation} class
#'
#' @rdname segmentation-class
#' @export


print.segmentation <- function(x,max.level = 1){
  str(x,max.level = max.level)
}


#' \code{plot.segmentation} plot object of \code{segmentation} class
#' - wrapper for \code{\link{plot_segm}}
#' @param separate whether plots should be merged into one graph with several
#'   axis or not (not working yet)
#' @param interactive whether plot are interactive (dygraphs/leaflet) or not (ggplot2)
#' @param xcol column for x axis. can be POSIXct
#' @param html whether htmltools::tagList should be applied on the returned
#'   object for integrating in html pages
#' @rdname segmentation-class
#' @export

plot.segmentation <- function(x,nseg=NULL,nclass=NULL, separate=T, interactive=F, xcol="indice", html = F,order = NULL) {
  if (is.null(order)){
    if (x$type == "home-range") order <- F
    if (x$type == "behavior") order <- T
  }
  if( x$seg.type == "segclust"){
    if (is.null(nclass)){
      nclass <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[nclass]
      message(paste("BIC-selected number of class : ",nclass," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[nclass]
      message(paste("User-specified number of class :",nclass,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    g <- plot_segm(data = x$data, output = x$outputs[[paste(nclass,"class -",nseg, "segments")]], separate = T, interactive=interactive, diag.var = x$`Diagnostic variables`,x_col = xcol, html = html, order = order)


  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    g <- plot_segm(data = x$data, output = x$outputs[[paste(nseg, "segments")]], separate = T, interactive=interactive, diag.var = x$`Diagnostic variables`,x_col = xcol, html = html, order = order)
  }
  return(g)
}




#' \code{likelihood.segmentation} plot likelihood estimates of a \code{segmentation} object
#' - works only for picard segmentation.
#' @rdname segmentation-class
#' @export

likelihood.segmentation <- function(x) {

  if( x$seg.type == "segclust"){
    likedat <- x$likelihood
    # nseg.bic <- x$Kopt.lavielle
    # tmpdf =  filter(li("nseg"=nseg.bic, "likelihood" = x$likelihood$likelihood[which(x$likelihood$nseg == nseg.bic)])
    g <- ggplot2::ggplot(dplyr::filter(likedat,nclass != 0,is.finite(likelihood)),ggplot2::aes(x=nseg,y=likelihood,col=factor(nclass)))+
      ggplot2::geom_point()+
      ggplot2::geom_line()+
      ggplot2::xlab("Number of segments")+
      ggplot2::ylab("log-Likelihood")+
      # ggplot2::geom_point(data = tmpdf,ggplot2::aes(x=nseg,y=likelihood,col = fact),size = 3)+
      scale_color_discrete(name="Number of \nCluster")

  } else if( x$seg.type == "segmentation"){
    nseg.lav <- x$Kopt.lavielle
    tmpdf =  data.frame("nseg"=nseg.lav, "likelihood" = x$likelihood$likelihood[which(x$likelihood$nseg == nseg.lav)])
    g <- ggplot2::ggplot(x$likelihood,ggplot2::aes(x=nseg,y=likelihood))+
      ggplot2::geom_point()+
      ggplot2::geom_line()+
      ggplot2::xlab("Number of segments")+ggplot2::ylab("log-Likelihood")+
      ggplot2::scale_color_discrete(name="Number of \nCluster") +
      ggplot2::geom_point(data = tmpdf,ggplot2::aes(x=nseg,y=likelihood),size = 3)
    }
  return(g)
}


#' \code{getlikelihood} returns likelihood estimates of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

get_likelihood <- function(x) {
  return(x$likelihood)
}




#' \code{BIC.segmentation} plot BIC estimates of a \code{segmentation} object
#' - works only for segclust algorithm.
#' @rdname segmentation-class
#' @export

BIC.segmentation <- function(x) {

  if( x$seg.type == "segclust"){
    likedat <- x$BIC
    g <- ggplot2::ggplot(filter(likedat,is.finite(BIC)),ggplot2::aes(x=nseg,y=BIC,col=factor(ncluster)))+ggplot2::geom_point()+ggplot2::geom_line()+ggplot2::xlab("Number of segments")+ggplot2::ylab("BIC")+scale_color_discrete(name="Number of \nCluster")

  } else if( x$seg.type == "segmentation"){
    stop("no BIC estimates for segmentation only algorithm")
  }
  return(g)
}


#' \code{getlikelihood} returns likelihood estimates of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

get_BIC <- function(x) {
  return(x$BIC)
}

#' \code{stateplot} plot state distribution of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

stateplot <- function(x,nseg = NULL,nclass = NULL,order = NULL){
  if (is.null(order)){
    if (x$type == "home-range") order <- F
    if (x$type == "behavior") order <- T
  }
  if( x$seg.type == "segclust"){
    if (is.null(nclass)){
      nclass <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[nclass]
      message(paste("BIC-selected number of class : ",nclass," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[nclass]
      message(paste("User-specified number of class :",nclass,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    g <- plot_states(x$outputs[[paste(nclass,"class -",nseg, "segments")]],x$`Diagnostic variables`,order= order)

  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    g <- plot_states(x$outputs[[paste(nseg, "segments")]],x$`Diagnostic variables`,order= order)

  }
  return(g)
}

#' \code{states} return data.frame with states statistics a \code{segmentation} object
#' @rdname segmentation-class
#' @export

states <- function(x,nseg = NULL,nclass = NULL){
  if( x$seg.type == "segclust"){
    if (is.null(order)){
      if (x$type == "home-range") order <- F
      if (x$type == "behavior") order <- T
    }
    if (is.null(nclass)){
      nclass <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[nclass]
      message(paste("BIC-selected number of class : ",nclass," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[nclass]
      message(paste("User-specified number of class :",nclass,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    return(x$outputs[[paste(nclass,"class -",nseg, "segments")]]$states)

  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    return(x$outputs[[paste(nseg, "segments")]]$states)
  }
}

#' \code{segment} return data.frame with segment information of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

segment <- function(x,nseg = NULL,nclass = NULL){
  if( x$seg.type == "segclust"){
    if (is.null(nclass)){
      nclass <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[nclass]
      message(paste("BIC-selected number of class : ",nclass," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[nclass]
      message(paste("User-specified number of class :",nclass,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(nclass,"class -",nseg, "segments")]]$states
    segmentdf <- x$outputs[[paste(nclass,"class -",nseg, "segments")]]$segments
    totdf <- dplyr::left_join(segmentdf,statesdf, by = "state")
    return(totdf)
  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(nseg, "segments")]]$states
    segmentdf <- x$outputs[[paste(nseg, "segments")]]$segments
    totdf <- dplyr::left_join(segmentdf,statesdf, by = "state")
    return(totdf)
  }
}

#' \code{augment.segmentation} return data.frame with original data and state information of a \code{segmentation} object
#' @param colname_state column name for the added state column
#' @rdname segmentation-class
#' @export

augment.segmentation<- function(x,nseg = NULL,nclass=NULL,colname_state = "state"){
  if(any(colnames(x$data) == colname_state)) stop(paste(colname_state,"already exists as column names of the data.frame. Cannot erase"))

  if( x$seg.type == "segclust"){
    if (is.null(nclass)){
      nclass <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[nclass]
      message(paste("BIC-selected number of class : ",nclass," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[nclass]
      message(paste("User-specified number of class :",nclass,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(nclass,"class -",nseg, "segments")]]$states

    df.segm  <- segment(x,nseg=nseg,nclass=nclass)
  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    statesdf <- x$outputs[[paste(nseg, "segments")]]$states
    df.segm  <- segment(x,nseg=nseg)
  }
  x$data$indice <- 1:nrow(x$data)
  evalstr  <- paste("data <- dplyr::mutate(x$data,",colname_state,"= df.segm[findInterval(indice,df.segm$begin,rightmost.closed = F,left.open = F),\"state\"])",sep="")
  eval(parse(text=evalstr))
  totdf <- dplyr::left_join(data,statesdf, by = "state")

  return(totdf)

}



#' \code{segmap} create maps with object of \code{segmentation} class
#' @param UTMstring projection string for the coordinates.
#' @param width for leaflet map
#' @param height for leaflet map
#' @param scale for dividing coordinates so that it works with leaflet
#'   (interpreting latitude/longitude)
#' @rdname segmentation-class
#' @export

segmap <-  function(x,interactive=F,nseg = NULL,nclass = NULL,xcol="expectTime",html=F,scale=100,UTMstring="+proj=utm +zone=35 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0",width=400,height=400,order = NULL){

  if (is.null(order)){
    if (x$type == "home-range") order <- F
    if (x$type == "behavior") order <- T
  }
  if( x$seg.type == "segclust"){
    if (is.null(nclass)){
      nclass <- x$ncluster.BIC
      nseg <- x$Kopt.BIC[nclass]
      message(paste("BIC-selected number of class : ",nclass," class.\nBIC-selected number of segment : ",nseg,sep=""))
    } else if (is.null(nseg)) {
      nseg <- x$Kopt.BIC[nclass]
      message(paste("User-specified number of class :",nclass,"\nBIC-selected number of segment : ",nseg,sep=""))
    }
    outputs = x$outputs[[paste(nclass,"class -",nseg, "segments")]]
  } else if( x$seg.type == "segmentation"){
    if( is.null(nseg) ){
      nseg <- x$Kopt.lavielle
      message(paste("Lavielle-selected number of segment : ",nseg,sep=""))
    }
    outputs = x$outputs[[paste(nseg, "segments")]]
  }
  map <- map_segm(data=x$data,output=outputs,interactive = interactive, x_col = x_col, html = html, scale=scale, UTMstring = UTMstring,width=width,height=height,order=order)

  return(map)
}

