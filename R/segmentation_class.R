#' segmentation class description
#'
#' @param x a \code{segmentation} object generated by
#'   \code{\link{segmentation}}
#' @param nseg number of segment chosen
#' @param nclass number of classes chosen
#' @name segmentation-class
NULL

#' \code{print.segmentation} prints object of \code{segmentation} class
#'
#' @rdname segmentation-class
#' @export


print.segmentation <- function(x,max.level = 1){
  str(x,max.level = max.level)
}


#' \code{plot.segmentation} plot object of \code{segmentation} class
#' - wrapper for \code{\link{plot_segm}}
#' @param separate whether plots should be merged into one graph with several
#'   axis or not (not working yet)
#' @param interactive whether plot are interactive (dygraphs/leaflet) or not (ggplot2)
#' @param xcol column for x axis. can be POSIXct
#' @param html whether htmltools::tagList should be applied on the returned
#'   object for integrating in html pages
#' @rdname segmentation-class
#' @export

plot.segmentation <- function(x,nseg=NULL,nclass=NULL, separate=T, interactive=F, xcol="indice", html = F) {
  if(x$type == 'picard'){
    if(is.null(nseg)) stop("nseg must be chosen for plotting picard segmentation")
    if(x$picard.type == 'variable_class'){
      if(is.null(nclass)) stop("nclass must be chosen for plotting variable_class segmentation")
      g <- plot_segm(data = x$data, output = x$outputs[[paste(nclass,"class -",nseg, "segments")]], separate = T, interactive=interactive, diag.var = x$`Diagnostic variables`,x_col = xcol, html = html)
    } else {
      g <- plot_segm(data = x$data, output = x$outputs[[paste(nseg, "segments")]], separate = T, interactive=interactive, diag.var = x$`Diagnostic variables`,x_col = xcol, html = html)
    }
    return(g)
  } else if (x$type == 'HMM'){
    g <- plot_segm(data = x$data, output = x$outputs, separate = T, interactive=interactive, diag.var = x$`Diagnostic variables`,x_col = xcol, html = html)
    return(g)
  }
}




#' \code{likelihood.segmentation} plot likelihood estimates of a \code{segmentation} object
#' - works only for picard segmentation.
#' @rdname segmentation-class
#' @export

likelihood.segmentation <- function(x) {
  if(x$type != 'picard') stop("likelihood only pertinent for picard segmentation")
  if(x$picard.type == 'variable_class'){
    g <- ggplot2::ggplot(filter(x$likelihood,nclass != 0,is.finite(likelihood)),ggplot2::aes(x=nseg,y=likelihood,col=factor(nclass)))+ggplot2::geom_point()+ggplot2::geom_line()+ggplot2::xlab("Number of segments")+ggplot2::ylab("log-Likelihood")

  } else  {
    g <- ggplot2::ggplot(x$likelihood,ggplot2::aes(x=nseg,y=likelihood))+ggplot2::geom_point()+ggplot2::geom_line()+ggplot2::xlab("Number of segments")+ggplot2::ylab("log-Likelihood")
  }
  return(g)
}


#' \code{stateplot} plot state distribution of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

stateplot <- function(x,nseg = NULL,nclass = NULL){
  if(x$type == 'picard'){
    if(is.null(nseg)) stop("nseg must be chosen for plotting picard states statistics")
    if(x$picard.type == 'variable_class'){
      if(is.null(nclass)) stop("nclass must be chosen for plotting variable_class segmentation")
      g <- plot_states(x$outputs[[paste(nclass,"class -",nseg, "segments")]],x$`Diagnostic variables`)
    } else  {
      g <- plot_states(x$outputs[[paste(nseg, "segments")]],x$`Diagnostic variables`)
    }
  } else if (x$type == 'HMM'){
    g <- plot_states(x$outputs,x$`Diagnostic variables`)
  }
  return(g)
}

#' \code{states} return data.frame with states statistics a \code{segmentation} object
#' @rdname segmentation-class
#' @export

states <- function(x,nseg = NULL,nclass = NULL){
  if(x$type == 'picard'){
    if(is.null(nseg)) stop("nseg must be chosen for getting states statistics")
    if(x$picard.type == 'variable_class'){
      if(is.null(nclass)) stop("nclass must be chosen for plotting variable_class segmentation")
      return(x$outputs[[paste(nclass,"class -",nseg, "segments")]]$states)
    }
    else {
      return(x$outputs[[paste(nseg, "segments")]]$states)
    }
  } else if (x$type == 'HMM'){
    return(x$outputs$states)
  }
}

#' \code{segment} return data.frame with segment information of a \code{segmentation} object
#' @rdname segmentation-class
#' @export

segment <- function(x,nseg = NULL,nclass = NULL){
  if(x$type == 'picard'){
    if(is.null(nseg)) stop("nseg must be chosen for getting segment statistics")
    if(x$picard.type == 'variable_class'){
      if(is.null(nclass)) stop("nclass must be chosen for plotting variable_class segmentation")
      return(x$outputs[[paste(nclass,"class -",nseg, "segments")]]$segments)
    } else {
      return(x$outputs[[paste(nseg, "segments")]]$segments)
    }
  } else if (x$type == 'HMM'){
    return(x$outputs$segments)
  }
}

#' \code{augment.segmentation} return data.frame with original data and state information of a \code{segmentation} object
#' @param colname_state column name for the added state column
#' @rdname segmentation-class
#' @export

augment.segmentation<- function(x,nseg = NULL,nclass=NULL,colname_state = "state"){
  if(any(colnames(x$data) == colname_state)) stop(paste(colname_state,"already exists as column names of the data.frame. Cannot erase"))

  if(x$type == 'picard'){
    if(is.null(nseg)) stop("nseg must be chosen for getting segment statistics")
    if(x$picard.type == 'variable_class'){
      if(is.null(nclass)) stop("nclass must be chosen for plotting variable_class segmentation")
      df.segm  <- segment(x,nseg=nseg,nclass=nclass)
    } else {
      df.segm  <- segment(x,nseg=nseg)
    }
    x$data$indice <- 1:nrow(x$data)
    evalstr  <- paste("data <- dplyr::mutate(x$data,",colname_state,"= df.segm[findInterval(indice,df.segm$begin,rightmost.closed = F,left.open = F),\"state\"])",sep="")
    eval(parse(text=evalstr))
    return(data)
    } else if (x$type == 'HMM'){
      cluster <- moveHMM::viterbi(x$model.hmm)
      data[,colname_state] <- cluster
  }
  return(data)
}



#' \code{segmap} create maps with object of \code{segmentation} class
#' @param UTMstring projection string for the coordinates.
#' @param width for leaflet map
#' @param height for leaflet map
#' @param scale for dividing coordinates so that it works with leaflet
#'   (interpreting latitude/longitude)
#' @rdname segmentation-class
#' @export

segmap <-  function(x,interactive=F,nseg = NULL,nclass = NULL,xcol="expectTime",html=F,scale=100,UTMstring="+proj=utm +zone=35 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0",width=400,height=400){
  if(x$type == 'picard'){
    if(is.null(nseg)) stop("nseg must be chosen for getting segment statistics")
    if(x$picard.type == 'variable_class'){
      if(is.null(nclass)) stop("nclass must be chosen for plotting variable_class segmentation")
      outputs = x$outputs[[paste(nclass,"class -",nseg, "segments")]]
    } else {
      outputs = x$outputs[[paste(nseg, "segments")]]
    }
    map <- map_segm(data=x$data,output=outputs,interactive = interactive, x_col = x_col, html = html, scale=scale, UTMstring = UTMstring,width=width,height=height)
  } else if (x$type == 'HMM'){
    map <- map_segm(data = x$data, output = x$outputs, interactive = interactive, x_col = x_col, html = html, scale=scale, UTMstring = UTMstring,width=width,height=height)
  }
  return(map)
}

